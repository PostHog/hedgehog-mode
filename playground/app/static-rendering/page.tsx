"use client";

import {
  HedgehogActorOptions,
  HedgehogActorColorOptions,
  StaticHedgehogRenderer,
  HedgehogActorAccessoryOptions,
  HedgehogActorSkinOptions,
  HedgehogActorAccessories,
  HedgehogActorAccessoryOption,
} from "@posthog/hedgehog-mode";
import { uniqueId } from "lodash";
import { useEffect, useRef, useState } from "react";

// NOTE: 100% generated by ChatGPT for fun!
function mulberry32(seed: number) {
  return function () {
    let t = (seed += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function deterministicShuffle<T>(array: T[], seed: number): T[] {
  const rng = mulberry32(seed);
  const arr = array.slice(); // copy to avoid mutating original
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// Generate all combinations of accessories, colors, and skins
let allCombinations = Object.values(HedgehogActorAccessoryOptions).flatMap(
  (accessory) =>
    Object.values(HedgehogActorColorOptions).flatMap((color) =>
      Object.values(HedgehogActorSkinOptions).map(
        (skin): HedgehogActorOptions => ({
          id: `hedgehog-${uniqueId()}`,
          accessories: [accessory],
          color,
          skin,
        })
      )
    )
);

// Create a list of all groups like { headwear: [foo, bar], eyewear: [baz], other: [qux] }
const accessoriesByGroup = Object.entries(HedgehogActorAccessories).reduce(
  (acc, [key, value]) => {
    acc[value.group] = acc[value.group] || [];
    acc[value.group].push(key as HedgehogActorAccessoryOption);
    return acc;
  },
  {} as Record<string, HedgehogActorAccessoryOption[]>
);

const accessoryCombos: Set<Set<HedgehogActorAccessoryOption>> = new Set();

for (const [group, accessories] of Object.entries(accessoriesByGroup)) {
  // Iterate over all the other groups and add each option

  for (const [otherGroup, otherAccessories] of Object.entries(
    accessoriesByGroup
  )) {
    if (group === otherGroup) {
      continue;
    }
    for (const accessory of accessories) {
      // Add jus the accessory on its own
      accessoryCombos.add(new Set([accessory]));
      // Add the accessory with each other accessory
      for (const otherAccessory of otherAccessories) {
        accessoryCombos.add(
          new Set([accessory, otherAccessory] as HedgehogActorAccessoryOption[])
        );
      }
    }
  }
}

// Create all possible combination of accessories by group
const accessories: HedgehogActorOptions[] = Array.from(accessoryCombos).map(
  (accessories) => ({
    accessories: Array.from(accessories),
    id: `hedgehog-${uniqueId()}`,
    skin: "default",
  })
);

// Deterministically shuffle the array
allCombinations = deterministicShuffle(allCombinations, 42);

function StaticHedgehog({
  hedgehog,
  renderer,
}: {
  hedgehog: HedgehogActorOptions;
  renderer: StaticHedgehogRenderer;
}) {
  const [image, setImage] = useState<string | null>(null);

  useEffect(() => {
    renderer.render(hedgehog, 160).then((image) => {
      setImage(image);
    });
  }, [hedgehog]);

  return (
    <>
      {!image ? (
        <div className="w-20 h-20 bg-gray-200" />
      ) : (
        <img width={80} height={80} src={image} />
      )}
    </>
  );
}

export default function StaticRendering() {
  const rendererRef = useRef<StaticHedgehogRenderer>();

  if (!rendererRef.current) {
    rendererRef.current = new StaticHedgehogRenderer({
      assetsUrl: "/assets",
    });
  }

  return (
    <div className="p-8 flex flex-col gap-2">
      <div>
        <h2 className="text-2xl font-bold">Accessories</h2>
        <div className="flex flex-wrap gap-2">
          {accessories.map((hedgehog, i) => (
            <StaticHedgehog
              hedgehog={hedgehog}
              renderer={rendererRef.current!}
              key={i}
            />
          ))}
        </div>
      </div>
      <div>
        <h2 className="text-2xl font-bold">All combinations</h2>
        <div className="flex flex-wrap gap-2">
          {allCombinations.map((hedgehog, i) => (
            <StaticHedgehog
              hedgehog={hedgehog}
              renderer={rendererRef.current!}
              key={i}
            />
          ))}
        </div>
      </div>
    </div>
  );
}
